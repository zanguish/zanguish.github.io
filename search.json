[{"title":"supervisor 进程管理","url":"%2F2019%2F08%2F02%2Fsupervisor%2F","content":"\n#### 安装和示例\n```\n# 安装\nsudo apt-get install supervisor\n# or\npip install supervisor\n\n# 测试是否安装成功\necho_supervisord_conf\n\n\n# 创建配置文件\necho_supervisord_conf > /etc/supervisord.conf \n\n# 启动服务\nsupervisord -c /etc/supervisord.conf\n# 停止服务\nsupervisorctl shutdown\n\n# 进程管理(supervisorctl help)\nsupervisorctl start\nsupervisorctl stop\nsupervisorctl reload\nsupervisorctl restart\nsupervisorctl status\n\n# 开启web页面\n[inet_http_server]         ; inet (TCP) server disabled by default\nport=*:9001                ; ip_address:port specifier, *:port for all iface\nusername=user              ; default is no username (open server)\npassword=123               ; default is no password (open server)\n\n\n\n# 示例\n[program:task1]                   ;\":\"后面是程序名称\ncommand=php task1.php             ;程序的启动命令\n;process_name=%(program_name)s_%(process_num)s   ;进程名称\n;numprocs=1                       ; 启动时的进程数 (默认 1)\ndirectory=/root                   ;执行时切换到的目录(def no cwd)\nuser=root                         ;指定用户运行\nstartsecs=3                       ;在设定时间内，程序必须保持运行(def. 1)\n;startretries=3                   ;当启动失败时尝试的最大次数(def 3)\nautostart=true                    ;是否跟随supervisord启动 (def: true)\nautorestart=true                  ;false[挂掉不重启],unexpected[非指定退出码重启],true[无条件重启](def: unexpected)\n;exitcodes=0,2                    ;'expected' 符合退出代码之后去重启 (def 0,2)\nredirect_stderr=true              ;是否开启程序标准输入输出重定向(def false)\nstdout_logfile_maxbytes=50MB      ;文件最大大小 # 日志文件进行切割 (def 50MB)\nstdout_logfile_backups=10         ; # 日志文件备份数目 (def 10)\nstdout_logfile=/root/task1.log    ;标准输出路径;(def AUTO)\n```\n\n####  配置说明\n\n```\n- command：启动程序使用的命令，可以是绝对路径或者相对路径\n- process_name：一个python字符串表达式，用来表示supervisor进程启动的这个的名称，默认值是%(program_name)s\n- numprocs：Supervisor启动这个程序的多个实例，如果numprocs>1，则process_name的表达式必须包含%(process_num)s，默认是1\n- numprocs_start：一个int偏移值，当启动实例的时候用来计算numprocs的值\n- priority：权重，可以控制程序启动和关闭时的顺序，权重越低：越早启动，越晚关闭。默认值是999\n- autostart：如果设置为true，当supervisord启动的时候，进程会自动重启。\n- autorestart：值可以是false、true、unexpected。false：进程不会自动重启，unexpected：当程序退出时的退出码不是exitcodes中定义的时，进程会重启，true：进程会无条件重启当退出的时候。\n- startsecs：程序启动后等待多长时间后才认为程序启动成功\n- startretries：supervisord尝试启动一个程序时尝试的次数。默认是3\n- exitcodes：一个预期的退出返回码，默认是0,2。\n- stopsignal：当收到stop请求的时候，发送信号给程序，默认是TERM信号，也可以是 HUP, INT, QUIT, KILL, USR1, or USR2。\n- stopwaitsecs：在操作系统给supervisord发送SIGCHILD信号时等待的时间\n- stopasgroup：如果设置为true，则会使supervisor发送停止信号到整个进程组\n- killasgroup：如果设置为true，则在给程序发送SIGKILL信号的时候，会发送到整个进程组，它的子进程也会受到影响。\n- user：如果supervisord以root运行，则会使用这个设置用户启动子程序\n- redirect_stderr：如果设置为true，进程则会把标准错误输出到supervisord后台的标准输出文件描述符。\n- stdout_logfile：把进程的标准输出写入文件中，如果stdout_logfile没有设置或者设置为AUTO，则supervisor会自动选择一个文件位置。\n- stdout_logfile_maxbytes：标准输出log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小\n- stdout_logfile_backups：标准输出日志轮转备份的数量，默认是10，如果设置为0，则不备份\n- stdout_capture_maxbytes：当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB\n- stdout_events_enabled：如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发\n- stderr_logfile：把进程的错误日志输出一个文件中，除非redirect_stderr参数被设置为true\n- stderr_logfile_maxbytes：错误log文件达到多少后自动进行轮转，单位是KB、MB、GB。如果设置为0则表示不限制日志文件大小\n- stderr_logfile_backups：错误日志轮转备份的数量，默认是10，如果设置为0，则不备份\n- stderr_capture_maxbytes：当进程处于stderr capture mode模式的时候，写入FIFO队列的最大bytes值，单位可以是KB、MB、GB\n- stderr_events_enabled：如果设置为true，当进程在写它的stderr到文件描述符的时候，PROCESS_LOG_STDERR事件会被触发\n- environment：一个k/v对的list列表\n- directory：supervisord在生成子进程的时候会切换到该目录\n- umask：设置进程的umask\n- serverurl：是否允许子进程和内部的HTTP服务通讯，如果设置为AUTO，supervisor会自动的构造一个url\n```\n\n####  linux 信号\n\n```\nkill -l \n0) EXIST  1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL\n 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE\n 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2\n13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT\n17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP\n21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU\n25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH\n29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN\n35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4\n39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8\n43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12\n47) SIGRTMIN+13 48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14\n51) SIGRTMAX-13 52) SIGRTMAX-12 53) SIGRTMAX-11 54) SIGRTMAX-10\n55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7  58) SIGRTMAX-6\n59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2\n63) SIGRTMAX-1  64) SIGRTMAX \n\n\n说明：\n只有第9种信号(SIGKILL)才可以无条件终止进程，SIGKILL信号进程无法捕获，进程也不得不无条件终止，其他信号进程都有权利忽略\nHUP 1 终端断线\nINT 2 中断（同 Ctrl + C）\nQUIT 3 退出（同 Ctrl + \\）\nTERM 15 终止\nKILL 9 强制终止\nCONT 18 继续（与STOP相反， fg/bg命令）\nSTOP 19 暂停（同 Ctrl + Z）\nCHLD 17 父进程或init进程进行收拾僵尸进程用到的信号\n\nkill (9)六亲不认的杀掉\n\nterm(15)正常的退出进程\n\n在系统中，SIGKILL和SIGSTOP两种信号，进程是无法捕获的，收到后会立即退出\n\nSIGTERM表示终止信号，是kill命令传送的系统默认信号，它与SIGKIIL的区别是，SIGTERM更为友好，进程能捕捉SIGTERM信号，进而根据需要来做一些清理工作\n\n```\n\n\n\n```php\ntask1.php\n<?php\n\n\npcntl_signal(SIGTERM, function ($signo) {\n    echo \"stop stop stop ...\";\n    exit();\n}, false);\n\nwhile (true) {\n    pcntl_signal_dispatch();\n    //print_r(getmypid() . '-----' . $argv[1]);\n    echo PHP_EOL;\n    echo date('Y-m-d H:i:s', time()) . PHP_EOL;\n    sleep(2);\n}\n\n?>\n```","tags":["supervisor"]},{"title":"git 常用操作","url":"%2F2018%2F12%2F18%2Fgit1%2F","content":"\n#### Git 撤销操作\n```\n回退命令：\n$ git reset --hard HEAD^         回退到上个版本\n$ git reset --hard HEAD~3        回退到前3次提交之前，以此类推，回退到n次提交之前\n$ git reset --hard commit_id     退到/进到 指定commit的sha码\n\n强推到远程：\n\n$ git push origin HEAD --force\n\n\ngit reset HEAD file 已暂存 撤销\ngit checkout -- file。 未暂存 撤销\n\n-----------\n\n已修改,未暂存\ngit checkout .\n或者\ngit reset --hard 慎用\n\n\n已暂存，未提交 撤销\n\ngit reset\ngit checkout .\n或者\ngit reset --hard 慎用\n\n已提交，未推送 撤销\ngit reset --hard origin/master\n\n已推送 撤销\ngit reset --hard HEAD^\ngit push -f\n\n\ngit log --pretty=oneline\n```\n\n\n#### Git 远程仓库 \n\n```\n1.查看现有远程仓库的地址url\ngit remote -v \n\n\n2.设置远程仓库地址\n\n//直接设置\ngit remote set-url origin <URL> \n\n//先删后添加\ngit remote rm origin \ngit remote add origin <URL>\n\n//编辑配置文件\n.git/conf\n\n\n3.添加多个远程仓库\ngit remote add origin <url1> \ngit remote set-url --add origin <url2> \ngit remote set-url --add origin <url3> \n\n```\n\n#### Git 配置相关\n\n```\n查看系统\ngit config --system --list\n\n查看全局\ngit config --global  --list\n\nuser.email=zw13476587420@163.com\nuser.name=zanguish\ncore.autocrlf=true\nssh.variant=ssh\n\n当前仓库\ngit config --local  --list\n\n设置\ngit config --global user.name \"myname\"\ngit config --global user.email  \"test@gmail.com\"\n\n```\n\n\n#### Git gitignore不起作用解决办法\n\n```\ngit rm -r --cached .\ngit add .\ngit commit -m 'update .gitignore'\n```\n\n\n#### Git stash\n\n```\n如果希望保留本地的改动,仅仅并入新配置项, 处理方法如下:\ngit stash\ngit pull\ngit stash pop\n\n如果希望用代码库中的文件完全覆盖本地工作版本. 方法如下:\ngit reset --hard\ngit pull\n\n\n\nstash 用法\ngit stash save \"message...\" 保存当前进度\ngit stash list 暂存区列表\ngit stash drop  [<stash>] 删除进度,默认最新的进度\ngit stash clear 删除所有存储的进度。\ngit stash apply [--index] [<stash>] 不删除进度,恢复进度\ngit stash pop [--index] [<stash>] 恢复进度,删除进度\ngit stash branch <branchname> <stash> 基于进度创建分支\ngit stash show [<stash>] 展示进度\n\n[--index] 参数：不仅恢复工作区，还恢复暂存区\n[<stash>] 进度编号\n```","tags":["git"]}]